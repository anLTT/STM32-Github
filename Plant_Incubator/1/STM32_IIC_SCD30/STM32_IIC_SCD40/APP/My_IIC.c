#include "My_IIC.h"
#include "gpio.h"

//*********************************************************************************
//IIC驱动
//
//*********************************************************************************
 void MY_delay_us__(const uint32_t ucus)
{
    register uint32_t ucustemp = ucus;
    while(ucustemp--)
    {
       (void)0;
    }
}
 
//初始化IIC
void IIC_Init(void)
{					     
	stc_gpio_cfg_t stcGpioCfg;
	DDL_ZERO_STRUCT(stcGpioCfg);
	///< 打开GPIO外设时钟门控
  Sysctrl_SetPeripheralGate(SysctrlPeripheralGpio, TRUE);	
	
  stcGpioCfg.enDir = GpioDirOut;   //IO输出
	stcGpioCfg.enDrv = GpioDrvH;		 //< 端口驱动能力配置->高驱动能力
  stcGpioCfg.enPu = GpioPuDisable; //无上拉
  stcGpioCfg.enPd = GpioPdDisable; //无下拉
	stcGpioCfg.enOD = GpioOdDisable; //< 端口开漏输出配置->开漏输出关闭
  
  Gpio_Init(IIC_SCL_PORT, IIC_SCL_PIN, &stcGpioCfg); //端口初始化 SCL
	Gpio_Init(IIC_SDA_PORT, IIC_SDA_PIN, &stcGpioCfg); //端口初始化 SDA
	
	Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL 输出高
	Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA 输出高

}

//IO方向设置
void SDA_IN()  
{ 
	stc_gpio_cfg_t stcGpioCfg;
	
	stcGpioCfg.enDir =GpioDirIn;
	stcGpioCfg.enDrv = GpioDrvH;		 //< 端口驱动能力配置->高驱动能力
  stcGpioCfg.enPu = GpioPuDisable; //无上拉
  stcGpioCfg.enPd = GpioPdDisable; //无下拉
 	Gpio_Init(IIC_SDA_PORT,IIC_SDA_PIN, &stcGpioCfg);
}
void SDA_OUT()
{ 
	stc_gpio_cfg_t stcGpioCfg;
	
	stcGpioCfg.enDir = GpioDirOut;   //IO输出
	stcGpioCfg.enDrv = GpioDrvH;		 //< 端口驱动能力配置->高驱动能力
  stcGpioCfg.enPu = GpioPuDisable; //无上拉
  stcGpioCfg.enPd = GpioPdDisable; //无下拉
	stcGpioCfg.enOD = GpioOdDisable; //< 端口开漏输出配置->开漏输出关闭
	
	Gpio_Init(IIC_SDA_PORT,IIC_SDA_PIN, &stcGpioCfg);
	
  Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA 输出高
//	IIC_SDA=1;
}


//产生IIC起始信号
void IIC_Start(void)
{
	SDA_OUT();     //sda线输出
//	IIC_SDA=1;	  	  
//	IIC_SCL=1;
//	delay_us(4);
  Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=1
	Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1
	MY_delay_us__(4);
	
// 	IIC_SDA=0;//START:when CLK is high,DATA change form high to low 
//	delay_us(4);
//	IIC_SCL=0;//钳住I2C总线，准备发送或接收数据 
	Gpio_ClrIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=0
	MY_delay_us__(4);
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
}	  
//产生IIC停止信号
void IIC_Stop(void)
{
	SDA_OUT();//sda线输出
//	IIC_SCL=0;
//	IIC_SDA=0;//STOP:when CLK is high DATA change form low to high
// 	delay_us(4);
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
	Gpio_ClrIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=0
	MY_delay_us__(4);
	
//	IIC_SCL=1; 
//	IIC_SDA=1;//发送I2C总线结束信号
//	delay_us(4);
	Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1
	Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=1
	MY_delay_us__(4);	
}
//等待应答信号到来
//返回值：1，接收应答失败
//        0，接收应答成功
u8 IIC_Wait_Ack(void)
{
	u8 ucErrTime=0;
	SDA_IN();      //SDA设置为输入  
//	IIC_SDA=1;delay_us(2);	   
//	IIC_SCL=1;delay_us(2);
  Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=1
	//delay 2 us
	Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1
	//delay 2 us
	
	while(READ_SDA)
	{
		ucErrTime++;
		if(ucErrTime>250)
		{
			IIC_Stop();
			return 1;
		}
	}
//	IIC_SCL=0;//时钟输出0 	   
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
	return 0;  
} 
//产生ACK应答
void IIC_Ack(void)
{
//	IIC_SCL=0;
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
	SDA_OUT();
//	IIC_SDA=0;
//	delay_us(2);
//	IIC_SCL=1;
//	delay_us(2);
//	IIC_SCL=0;
	Gpio_ClrIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=0
	//delay 2 us
	Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1
	//delay 2 us	
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
}
//不产生ACK应答		    
void IIC_NAck(void)
{
//	IIC_SCL=0;
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
	SDA_OUT();
	
//	IIC_SDA=1;
//	delay_us(2);
//	IIC_SCL=1;
//	delay_us(2);
//	IIC_SCL=0;
	
  Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=1
	//delay 2 us	
	Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1
	//delay 2 us		
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
}					 				     
//IIC发送一个字节
//返回从机有无应答
//1，有应答
//0，无应答			  
void IIC_Send_Byte(u8 txd)
{                        
    u8 t;   
		SDA_OUT(); 	    
//    IIC_SCL=0;//拉低时钟开始数据传输
	Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
    for(t=0;t<8;t++)
    {              
		if((txd&0x80)>>7)
			//IIC_SDA=1;
		  Gpio_SetIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=1
		else
			//IIC_SDA=0;
		  Gpio_ClrIO(IIC_SDA_PORT, IIC_SDA_PIN); // SDA=0
		txd<<=1; 	  
//		delay_us(2);   //对TEA5767这三个延时都是必须的
//		IIC_SCL=1;
//		delay_us(2); 
//		IIC_SCL=0;	
//		delay_us(2);
		MY_delay_us__(2);
		Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1
		MY_delay_us__(2);
		Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
		MY_delay_us__(2);
    }	 
} 	    
//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
u8 IIC_Read_Byte(unsigned char ack)
{
	unsigned char i,receive=0;
	SDA_IN();//SDA设置为输入
    for(i=0;i<8;i++ )
	{
    Gpio_ClrIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=0
		MY_delay_us__(0);
    Gpio_SetIO(IIC_SCL_PORT, IIC_SCL_PIN); // SCL=1    
		//IIC_SCL=0; 
    //delay_us(2);
		//IIC_SCL=1;
        receive<<=1;
        if(READ_SDA)receive++;   
		//delay_us(1); 
    }					 
    if (!ack)
        IIC_NAck();//发送nACK
    else
        IIC_Ack(); //发送ACK   
    return receive;
}



























